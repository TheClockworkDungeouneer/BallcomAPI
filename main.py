## SQL lite, SQLmodel


import os 

import uvicorn
from multiprocessing import freeze_support

import jinja2

from sqlmodel import Field, Session, SQLModel, create_engine, select
from sqlalchemy.exc import MultipleResultsFound, NoResultFound

import datetime

import json, shutil
from fastapi.encoders import jsonable_encoder

from typing import Union, List, Dict, Optional #, json	#, TypedDict
from typing_extensions import TypedDict
import starlette.status as status
#from starlette.status import HTTP_302_FOUND, HTTP_303_SEE_OTHER
from starlette.status import HTTP_302_FOUND, HTTP_303_SEE_OTHER, HTTP_500_INTERNAL_SERVER_ERROR

from fastapi import Depends, FastAPI, Query, Path, Form, Request, File, UploadFile, Response, HTTPException, Cookie
from starlette.responses import RedirectResponse
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from pydantic import BaseModel

from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

from jose import JWTError, jwt

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
#from passlib.context import CryptContext

import html

from dotenv import load_dotenv

## Relative Imports------------
from routers import proxy, roundtable
from dependencies import security
from dependencies.database import * 
from dependencies.templating import templates
#, user, site, artjuggle



## --------------â€-------------



load_dotenv()

SECRET_KEY = os.environ.get("SECRET_KEY")
ALGORITHM = os.environ.get("ALGORITHM")
ACCESS_TOKEN_EXPIRE_MINUTES = 30 #os.environ("ACCESS_TOKEN_EXPIRE_MINUTES")
DEFAULT_TOKEN_EXPIRE_MINUTES = 15 #os.environ("DEFAULT_TOKEN_EXPIRE_MINUTES")

##pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


ROOT_PATH = "/api"


'''class SiteData(TypedDict):
		name: Union[str, None] = "Unamed Site"
		description: Union[str, None] = None
		file_path: str
		img_path: Union[str, None] = None
'''

dirname = os.path.dirname(__file__)
def json_path(file):
	return (os.path.join(os.path.dirname(__file__), f'Data/JSON/{file}'))


class Sanitizer:
	'''Class containing methods for data sanitization'''
	
	'''def __init__(self, data: Union[str, Dict, List] , whitelist: Optional[dict], blacklist: Optional[dict]):
		self.data = data
		self.whitelist = whitelist
		self.blacklist = blacklist'''

	def HTML_Clean(data: Union[str, Dict[str,str], List[str]]) -> Union[str, Dict[str,str]]:
		'''Escapes HTML in data <string, dict, or list> using html.escape()'''
		input = data
		if type(input) == str:
			output = html.escape(input, True)
		else: 
			output = {}
			for i in input:
				output[html.escape(i)] = html.escape(input[i])
				
		if input != output:
			print("HTML_CLEANED")
		return output

	def JSON_Clean():
		"""Unimplemented | Unlikely to be implemented | Would clean data to be saved to JSON to prevent characters which would damage the file"""
		pass
	def Custom_Clean():
		"""Unimplemented | Will clean data with whitelist or blacklist. Blacklist is dictionary formated as <term>:<replacement>"""
		pass


class SiteData(BaseModel):
	file_path: str	
	name: Optional[str] = "Unamed Site"
	description: Optional[str] = None
	img_path: Optional[str] = None
	last_updated: Optional[str] = datetime.datetime.today() 
		## having difficulties with default value None, defaults to "string"
	enabled: Optional[bool] = True

class Site(BaseModel):
	site_id:int
	site_data: Union[SiteData,None]  # :Optional[SiteData]

class SiteList(BaseModel):
	__root__: List[Union[SiteData,None]]

class JSON_packet(BaseModel):
	packet_id: int
	JSON_data: Dict
	sent_time: str = datetime.datetime.utcnow()
	
class Token(BaseModel):
    access_token: str
    token_type: str
class TokenData(BaseModel):
    username: Union[str, None] = None

'''
class Site2(SQLModel, table=True):
	id: Optional[int] = Field(default=None, primary_key=True)	## value is generated by database
	name: Optional[str] = Field(default=None, index=True)
	description: Optional[str] = None
	img_path: Optional[str] = None
	file_path: Optional[str] = None
	last_updated: Optional[str] = datetime.datetime.utcnow()
	enabled: bool = Field(default=True, index=True)

class User(SQLModel, table=True):
	id: Optional[int] = Field(default=None, primary_key=True)	## value is generated by database
	Username: Optional[str] = Field(default=None, index=True)
	Email: Optional[str] = Field(default=None, index=True)
	Hashed_Password: str
	##UserData: <Data class>
	enabled: bool = Field(default=True, index=True,description="Can be used to disable the accounts of chronically online dingi")

class BaseUser(SQLModel):
    username: str = Field(index=True)
    email: Optional[str] = Field(index=True)

class CreateUser(BaseUser):
    password: str


class ArtPost(SQLModel, table=True):
	id: Optional[int] = Field(default=None, primary_key=True)	## value is generated by database
	Title: str = Field(index=True)
	description: Optional[str] = None
	image_path: Optional[str] = None
	last_updated: Optional[str] = datetime.datetime.utcnow()
	enabled: bool = Field(default=True, index=True)


__table_args__ = {'extend_existing': True}

sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///Data/SQL_Model/{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, echo=True, connect_args=connect_args)
#engine = create_engine(sqlite_url, echo=True)

if False:
    security.oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")



def create_db_and_tables():
	SQLModel.metadata.create_all(engine)
'''
if False:
    def get_session() -> Session:
    	with Session(engine) as session:
    		yield session
    		#return session
    		
    
    '''
    def fake_decode_token(token):
        return User(
            username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
        )
    '''
    async def get_current_user(token: str = Depends(security.oauth2_scheme), session: Session = Depends(security.get_session)):
    	credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
    		)
    	try:
    		payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    		print(payload)
    		username: str = payload.get("sub")
    		if username is None:
    			raise credentials_exception
    		token_data = TokenData(username=username)
    	except JWTError:
    		raise credentials_exception
    	#user = get_user(fake_users_db, username=token_data.username)
    	#user = session.get(User, username=token_data.username)
    	try:
    		#session = security.get_session()
    		user = session.exec(select(User).where(User.Username==username)).one()
    	except MultipleResultsFound:
    		raise HTTPException(
    			status_code=500,
    			detail="Theres only supposed to be one of each username. Tell Max that the database is broken. Booooo I gotta fix it now."
    			)
    	if user is None:
    		raise credentials_exception
    	return user
    	'''
    	user = session.get(User, fake_decode_token(token))
    	if not user.enabled:
    		raise HTTPException(status_code=400, detail="Inactive user")
    		return user
    	'''
    
    def verify_password(plain_password, hashed_password):
        return security.pwd_context.verify(plain_password, hashed_password)
    
    def get_password_hash(password):
        return security.pwd_context.hash(password)
    
    #def security.authenticate_user(username: str, password: str, session: Session = Depends(security.get_session)):
    def authenticate_user(form_data: OAuth2PasswordRequestForm = Depends(), session:Session = Depends(security.get_session)):
    	print("test3")
    	#user = session.get(User, username)
    	#, session:Session = Depends(security.get_session)
    	try:
    		#session = security.get_session()
    		user = session.exec(select(User).where(User.Username==form_data.username)).one()
    	except MultipleResultsFound:
    		raise HTTPException(
    			status_code=500,
    			detail="Theres only supposed to be one of each username. Tell Max that the database is broken. Booooo I gotta fix it now."
    			)
    	except NoResultFound:
    		raise HTTPException(
    			status_code=401,
    			detail=f"Username \"{form_data.username}\" was not found."	
    			)
    	print("test6", user)
    	if not user:
    		print("test7")
    		#return False
    		raise HTTPException(
    			status_code=status.HTTP_401_UNAUTHORIZED,
    			detail="Incorrect username or password",
    			headers={"WWW-Authenticate": "Bearer"},
    		)
    	if not verify_password(form_data.password, user.Hashed_Password):
    		print("passwrong")
    		raise HTTPException(
    			status_code=status.HTTP_401_UNAUTHORIZED,
    			detail="Incorrect username or password",
    			headers={"WWW-Authenticate": "Bearer"},
    		)
    	print("test5")
    	return user
    
    def create_access_token(data: dict, expires_delta: Union[datetime.timedelta, None] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.datetime.utcnow() + expires_delta
        else:
            expire = datetime.datetime.utcnow() + datetime.timedelta(minutes=DEFAULT_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    
    
    def site_dict(num_cards:int):
    	try:
    		with open(json_path("sites.json"), "r") as raw_file:
    			#print(type(json.load(raw_file)))
    			cooked_file = json.load(raw_file)
    			#print(type(raw_file))
    			#print(type(json.load(raw_file)))
    			#cooked_file = Response(json.load(raw_file))
    			return (cooked_file)
    	except json.JSONDecodeError:
    		raise HTTPException(status_code=404, detail="JSON file empty")



description = """
Ballcom Database API is an API designed to interact with the Ballcom Site Library database.

## Sites

You can:
**read items** and also **.

## Sites

You will be able to:

* **Create site listings**.
* **Read site listings**.
* **Modify site listings** (_not implemented_)
"""


app = FastAPI(
    title="Ballcom Database API",
    description=description,
    version="0.0.1",
	terms_of_service="./static/terms",
    contact={
        "name": "Ballcom Dev(s)",
        #"url": "",
        "email": "ballcomtact@gmail.com",
    },
    license_info={
        "name": "Nginx",
        "url": "http://nginx.org/LICENSE",
    },
    root_path = ROOT_PATH
)

app.include_router(proxy.router)
app.include_router(roundtable.router)




@app.on_event("startup")
def on_startup():
    create_db_and_tables()



script_dir = os.path.dirname(__file__)
st_abs_file_path = os.path.join(script_dir, "static/")
app.mount("/static", StaticFiles(directory=st_abs_file_path), name="static")

#app.mount("/static", StaticFiles(directory="static"), name="static")


#templates = Jinja2Templates(directory=os.path.join(script_dir, "Templates/"))
statics = Jinja2Templates(directory=os.path.join(script_dir, "static/"))
HostLibrary = Jinja2Templates(directory=os.path.join(script_dir, "HostLibrary/"))
print(os.path.join(script_dir, "HostLibrary/"))
#



#print("bacon")
@app.get("/")
async def Root():
	#print("eggs")
	#return RedirectResponse(f'{ROOT_PATH}/Library', status_code=status.HTTP_302_FOUND)
	return RedirectResponse('./library', status_code=status.HTTP_302_FOUND)


@app.get("/library", response_class=HTMLResponse)
async def library(*,
    request: Request,
	#session: Session = Depends(security.get_session),
	#name: Optional[str] = None,
	#context: Request,			  
    page: Union[int, None] = None,
    id: str = "0"
):
	num_sites = 5

	##print(page)
	'''return templates.TemplateResponse("test.html", {
	 "request": request,
	 "id": id,
	 "page": page
	})'''
	#result = templates.TemplateResponse("test.html", 
	#	{
	 #		"id": id,
	 #		"page": page
	#)
	##if name:
	##file_path = session.exec(select(Site2).where(User.name==name)).one()
	##result = HostLibrary.TemplateResponse(file_path, {"reqest": request})
	##else:
	#result = statics.TemplateResponse("HTML/MadBall.html", {"request": request, "id": id, "page": page})
	result = HostLibrary.TemplateResponse("BallcomHosting/HTML/BallcomLibrary.html", {"request": request, "id": id, "page": page})
	return result

@app.get("/library/{name}", response_class=HTMLResponse)
async def library_get(*,
    request: Request,
	session: Session = Depends(security.get_session),
	name: Optional[str] = None,
	#context: Request,			  
    page: Union[int, None] = None,
    id: str = "0"
):
	num_sites = 5

	##print(page)
	'''return templates.TemplateResponse("test.html", {
	 "request": request,
	 "id": id,
	 "page": page
	})'''
	#result = templates.TemplateResponse("test.html", 
	#	{
	 #		"id": id,
	 #		"page": page
	#)
	##if name:
	try:
		file_path = session.exec(select(Site2).where(Site2.name==name)).one()
	except MultipleResultsFound:
		raise HTTPException(500, detail="Duplicate site names in database")
	if file_path is None:
		HTTPException(4, detail="Requested site was not found. Sorry!")
	elif file_path.file_path is None:
		raise HTTPException(404, detail="Requested site has no file attached")
	result = HostLibrary.TemplateResponse(file_path.file_path, {"request": request})
	##else:
	##	result = statics.TemplateResponse("HTML/MadBall.html", {"request": request, "id": id, "page": page})
	return result


##@app.get("/Library", response_class=HTMLResponse)
'''
@app.get("/library/{name}", response_class=HTMLResponse)
async def library(*,
    request: Request,
	session: Session = Depends(security.get_session),
	name: Optional[str] = None,
	#context: Request,			  
    page: Union[int, None] = None,
    id: str = "0"
):
	num_sites = 5

	##print(page)
	"""return templates.TemplateResponse("test.html", {
	 "request": request,
	 "id": id,
	 "page": page
	})
	#result = templates.TemplateResponse("test.html", 
	#	{
	 #		"id": id,
	 #		"page": page
	#)
	"""
	if name:
		file_path = session.exec(select(Site2).where(User.name==name)).one()
		result = HostLibrary.TemplateResponse(file_path, {"reqest": request})
	else:
		result = statics.TemplateResponse("HTML/MadBall.html", {"request": request, "id": id, "page": page})
	return result
'''

@app.get("/API/sitelist")
async def access_sites(session: Session = Depends(security.get_session), offset: int = Query(default=0, description="Where in the site database to start",ge=0), limit: int = Query(default=1, description="How many sites to return", ge=1, lt=32)):
	sites = session.exec(select(Site2).offset(offset).limit(limit)).all()
	return sites
	#path = (os.path.join(os.path.dirname(__file__), f'Data/JSON/{file}'))
	#return HTMLresponse()


@app.post("/post_site")
async def post_site(site: Site2, session: Session = Depends(security.get_session)):
	#with Session(engine) as session:
	#c_data = Sanitizer.HTML_Clean(site)
	session.add(site)
	session.commit()
	session.refresh(site)
	return site
	
	'''##item_dict = item.dict()
	##sites.(site.site_id) = site
	##print(sites)
	with open(json_path("sites.json"), "r") as file: 
		try:
			data=json.load(file)
		except:
			data={}

	stuff = site.site_id
	data.update({str(stuff) : (site.site_data).dict()})

	with open(json_path("sites.json"), "w") as file: 
		json.dump(data, file)
	return data'''
	


@app.get("/API/GET/{content}/")
async def API_GET(*,
    #request: Request,
    content: Union[str, None],
	loc: Union[List[str], None] = Query(None, description="An opptional list of requested dictionary keys. If included, only requested dictionary information will be returned, for example /Library loc will return by site IDs. If excluded the entire dictonary will be returned")
):
	try:
		with open(json_path("API_PATH.json"), "r") as file: 
			data=json.load(file)
	except json.JSONDecodeError:
		raise HTTPException(status_code=404, detail="JSON path director was not found or returned invalid.")
	try:
		with open(json_path(data[str(content)]), "r") as file: 
			data=json.load(file)
	except json.JSONDecodeError:
		raise HTTPException(status_code=404, detail="JSON path director failed to return valid JSON file.")	

	if loc:
		result = {}
		for i in loc:
			result[i] = data[int(i)]
		return result
	else:
		return data


@app.post("/API/POST/MadBall/", status_code=status.HTTP_201_CREATED)
async def MadBall(
	greeting: str = Form(),
	sarcasm: bool = Form(False),
	bob_button: str = Form(),
	message: Optional[str] = Form(None),
	c_close: str = Form(),
	sender: str = Form()
):
	
	try:
		with open(json_path("API_PATH.json"), "r") as file: 
			#data=json.load(file)
			path=json.load(file)[str("MadBall")]
			#print(json_path(path))
	except json.JSONDecodeError:
		raise HTTPException(status_code=404, detail="JSON path director was not found or is invalid.")
	
	try:
		with open(json_path(path), "r") as file: 
			data=json.load(file)
	except json.JSONDecodeError:
		raise HTTPException(status_code=404, detail="JSON path director failed to return valid JSON file.")

	data.update({str(int(max(data))+1):{
		"greeting": greeting,
		"sarcasm": sarcasm,
		"bob_button": bob_button,
		"message": message,
		"c_close": c_close,
		"sender": sender,
		"sent_time": str(datetime.datetime.today())
	}})

	#(packet.JSON_data).update({"sent_time":str(packet.sent_time)})
	#print(packet.JSON_data)
	#data.update({str(packet.packet_id) : (packet.JSON_data)})
	
	#data.update({str(site.site_id):(site.site_data).dict()})
	
	with open(json_path(path), "w") as file: 
		json.dump(data, file)
	#pass
	#print(greeting, sarcasm, bob_button, message, c_close, sender)
	#return {"msg":f"crabs successful {sarcasm}"}
	return HTMLResponse(content="<h1>Thanks for balling, you have saved the world</h1><a href=\"/Library\"><h2>Back to Ballcom</h2></a>", status_code=status.HTTP_201_CREATED)


@app.post("/API/POST/{content}/")
async def API_POST(*,
    request: Request,
	packet: JSON_packet,
	#packet: TypedDict[TypedDict["id":int],TypedDict["body":dict]],
    content: Union[str, None],
	loc: Union[List[str], None] = Query(None, description="An opptional list of requested dictionary keys. If included, only requested dictionary information will be returned, for example /Library loc will return by site IDs. If excluded the entire dictonary will be returned")
):
	try:
		with open(json_path("API_PATH.json"), "r") as file: 
			#data=json.load(file)
			path=json.load(file)[str(content)]
			#print(json_path(path))
	except json.JSONDecodeError:
		raise HTTPException(status_code=404, detail="JSON path director was not found or is invalid.")
	try:
		with open(json_path(path), "r") as file: 
			data=json.load(file)
	except json.JSONDecodeError:
		raise HTTPException(status_code=404, detail="JSON path director failed to return valid JSON file.")

	(packet.JSON_data).update({"sent_time":str(packet.sent_time)})
	print(packet.JSON_data)
	data.update({str(packet.packet_id) : (packet.JSON_data)})
	
	#data.update({str(site.site_id):(site.site_data).dict()})
	
	with open(json_path(path), "w") as file: 
		json.dump(data, file)
	return {"status":"success","path":json_path(path),"content":data}


@app.get("/users/me")
async def read_user_me(current_user: User = Depends(security.get_current_user)):
	return current_user

#, response_model=Token
@app.post("/login")
async def login_token(request: Request, response: Response, form_data: OAuth2PasswordRequestForm = Depends(), user: User = Depends(security.authenticate_user)):
	#user_dict = #users_db.get(form_data.username)User
	#print("test1")
	#user = auth(form_data.username, form_data.password)
	#user = auth
	#print("test2")
    '''
    if not user:
    	raise HTTPException(
    		status_code=status.HTTP_401_UNAUTHORIZED,
    		detail="Incorrect username or password",
    		headers={"WWW-Authenticate": "Bearer"},
    	)
    '''
    access_token_expires = datetime.timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
		data={"sub": user.Username}, expires_delta=access_token_expires
    )
    response.set_cookie(key="cookie_token", value=access_token, httponly=True,secure=True, max_age=(60*ACCESS_TOKEN_EXPIRE_MINUTES))
    return {"access_token": access_token, "token_type": "bearer", "detail": "Login accepted"}

    #return static.TemplateResponse("", templates.TemplateResponse("test.html", {"request": request}) #{"access_token": access_token, "token_type": "bearer"}
    #return templates.TemplateResponse("test.html", {"request": request}) #{"access_token": access_token, "token_type": "bearer"}
	
    '''
	if not user_dict:
		raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Incorrect username or password")
	user = ""
	if not hashed_password == user.hashed_password:
		raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Incorrect username or password")
	
	return {"access_token": user.username, "token_type": "bearer"}
    '''

    '''
    @app.get("/login"):
    '''	
@app.get("/login")
async def get_login_page(request: Request, root_path:str = ROOT_PATH):
	response = templates.TemplateResponse("Login.html", {"request": request, "root_path": root_path})
	return response

@app.post("/signup")
async def create_user(*, session:Session = Depends(security.get_session), user:CreateUser):
    newUser = User.from_orm(user,
            {"Hashed_Password":security.get_password_hash(user.Password)})
    ##newUser.Hashed_Password = security.get_password_hash(user.Password)
    session.add(newUser)
    session.commit()
    session.refresh(newUser)
    return newUser.json(exclude=[Hashed_Password])


@app.get("/admin")
async def Open_Admin_Tools(token: str = Depends(security.oauth2_scheme)):
	return {"token":token}
'''
@app.post("/hash")
async def Test_Hash(password:str):
	return get_password_hash(password)
'''

@app.get("/artjuggle")
def get_artjuggle_home(request: Request):
	response = templates.TemplateResponse("FlexArtJuggle.html", {"request": request})
	return response


@app.get("/artjuggle/posts")
def get_artjuggle(session: Session = Depends(security.get_session)):
    statement = select(ArtPost3).where(ArtPost3.enabled == True)
    responseJSON = session.exec(statement).all()
    print(responseJSON)
    return responseJSON

@app.get("/artjuggle/posts/{id}")
def get_art_image(id: int = Path(gt=0), session: Session = Depends(security.get_session)):
    statement = select(ArtPost3.image_path, ArtPost3.mime_type).where(ArtPost3.id == id and ArtPost3.enabled == True)
    response = session.exec(statement).one()
    with open(response.image_path, "rb") as file:
        responseImage: bytes = file.read() 
    return Response(content=responseImage, media_type=response.mime_type)

@app.get("/artjuggle/post")
async def artjuggle_create(request: Request):    
    return templates.TemplateResponse("PostArtJuggle.html", {"request": request})  

@app.post("/artjuggle")
async def post_artjuggle(
    title:str = Form(),
    description: Optional[str] = Form(None),
    user: User = Depends(security.get_current_user),  # str = Form(), ## temporary | use JWT TOKEN
    session: Session = Depends(security.get_session),
    image: UploadFile = File(),
    #last_updated: Optional[str] = datetime.datetime.today()
): 
    if ('image/' not in image.content_type):
        raise HTTPException(400, detail="Invalid image format") 
    #if (image.content_type not in ['image/png', 'image/jpg', 'image/jpeg', 'image/tiff', 'image/bmp', 'image/gif']):
    image_path = '/mnt/sda/ballcom/artjuggle/images/'
    image_name = (user.Username + "|" + title + "|" + image.filename).replace(" ", "_")       ## use UUID??+reduce risk of insertion
    file_path = os.path.join(image_path,image_name) 
    mime_type = image.content_type

    db_post = ArtPost3(
            title=title,
            author=user.Username, ## Use relational db
            description=description,
            image_path=file_path,
            image_name=image_name,
            mime_type=mime_type
            )
    session.add(db_post)

    try:
        with open(file_path, "bx") as file:
            file.write(image.file.read())       # doesnt like await, idk why | implement chunking to protect memory + implement max size
    except FileExistsError:
        raise HTTPException(409, detail= f"Image in post already exsists. Please post image with different name or account.")
    
    session.commit()

    return {"title":title,"author":user.Username,"description":description,"filename":
        image.filename,"stored_name":image_name,"content_type":mime_type, "last_updated":datetime.datetime.today()}
    

@app.post("/fileshare") # ADD SECURITY SCOPE
async def post_fileshare(
    user: User = Depends(security.get_current_user),  # str = Form(), ## temporary | use JWT TOKEN
    #file_url:,
    file: UploadFile = File(),
    #last_updated: Optional[str] = datetime.datetime.today()
    file_name:Optional[str] = Form(None),
): 
    if not file_name:
        file_name = file.filename
    file_path = '/mnt/sda/fileshare/'
    #image_name = (author + "|" + image.filename).replace(" ", "_")       ## use UUID??
    full_path = os.path.join(file_path,file_name) 
    try:
        with open(full_path, "bx") as newfile:
            newfile.write(file.file.read())       # doesnt like await, idk why | implement chunking to protect memory + implement max size
    except FileExistsError:
        raise HTTPException(409, detail="Image in post already exsists. Please post image with different name or account.")
    return {"filename":file_name,"author":user.Username,"name":
            file.filename, "last_updated":datetime.datetime.today()}



# if __name__ == '__main__':
# 	freeze_support()
# 	'''print(f'{os.path.dirname(__file__)}\\main:app')
# 	uvicorn.run(f'{os.path.dirname(__file__)}\\main:app', reload=True, host="0.0.0.0")'''
# 	uvicorn.run("main:app", reload=False, host="0.0.0.0")

#r
